---
import MainLayout from "../layouts/MainLayout.astro";

const objectRows = [
  {
    object: "Field lineage annotation",
    where: "Code comments above struct fields, or sidecar `fields:` section",
    syntax: "// strict-source: ServiceName",
    why: "Declares per-field provenance, ownership, and drift semantics."
  },
  {
    object: "Sidecar file",
    where: "`strict-lineage.yml` at project or package root",
    syntax: "Standard YAML",
    why: "Centralizes upstream service definitions and per-field lineage metadata."
  },
  {
    object: "Source entry",
    where: "Inside `sources:` in a multi-line annotation or sidecar",
    syntax: "YAML with kind, target, path, scope, contract",
    why: "Defines the upstream contract edge used for blast-radius tracing."
  },
  {
    object: "Service registry record",
    where: "`.stricture/strict-lineage-systems.yaml` (or equivalent registry file)",
    syntax: "systems[] objects",
    why: "Defines service-level ownership, runbooks/docs, escalation defaults, and flow memberships."
  },
  {
    object: "Flow registry catalog",
    where: "Top-level in `.stricture/strict-lineage-systems.yaml`",
    syntax: "strict_flows objects",
    why: "Defines named business flows and numeric tier levels for policy gating."
  },
  {
    object: "Temporary lineage override",
    where: "Code comments during migration windows",
    syntax: "// strict-lineage-override ...",
    why: "Allows time-bounded exceptions with explicit reason and expiry."
  }
];

const annotationKeys = [
  { key: "from", required: "Yes", defaultValue: "None", purpose: "Source system name (and optional version). The only required field.", mode: "manual-required" },
  { key: "scope", required: "No", defaultValue: "From sidecar `upstream.*.scope` or `internal`", purpose: "Where the upstream lives: internal, cross_repo, or external.", mode: "defaulted" },
  { key: "provider", required: "No (external only)", defaultValue: "From sidecar `upstream.*.provider`", purpose: "Third-party provider ID for external sources.", mode: "defaulted" },
  { key: "transform", required: "No", defaultValue: "`passthrough`", purpose: "How data is modified: passthrough, normalize, aggregate.", mode: "defaulted" },
  { key: "merge", required: "No", defaultValue: "`single_source`", purpose: "Merge strategy for multi-source fields: single_source, priority.", mode: "defaulted" },
  { key: "classification", required: "No", defaultValue: "`internal`", purpose: "Data sensitivity classification.", mode: "defaulted" },
  { key: "break_policy", required: "No", defaultValue: "`strict`", purpose: "Compatibility policy for drift severity.", mode: "defaulted" },
  { key: "note", required: "No", defaultValue: "None", purpose: "Free-text context.", mode: "manual-optional" }
];

const autoInferredKeys = [
  { key: "field", defaultValue: "From struct field on next line", purpose: "Dot path of the API output field.", mode: "autogen" },
  { key: "field_id", defaultValue: "Derived from `field`", purpose: "Stable field identity slug.", mode: "autogen" },
  { key: "source_version", defaultValue: "From sidecar `version` or `from` qualifier", purpose: "Producer version for this mapping.", mode: "autogen" },
  { key: "contract", defaultValue: "From sidecar `upstream.*.contract`", purpose: "Contract artifact reference.", mode: "autogen" },
  { key: "owner", defaultValue: "`team.<system_slug>`", purpose: "Owning team for this field contract.", mode: "autogen" },
  { key: "escalation", defaultValue: "`slack:#<system_slug>-oncall`", purpose: "Escalation channel for incidents.", mode: "autogen" },
  { key: "confidence", defaultValue: "`declared`", purpose: "How trusted the mapping is: declared or inferred.", mode: "autogen" },
  { key: "contract_test_id", defaultValue: "`ci://contracts/<system>/<field_id>`", purpose: "Reference to contract test coverage.", mode: "autogen" },
  { key: "introduced_at", defaultValue: "Git blame date", purpose: "First-known introduction date.", mode: "autogen" },
  { key: "flow", defaultValue: "`from @<system> mapped @self`", purpose: "Human-readable flow summary.", mode: "autogen" },
  { key: "annotation_schema_version", defaultValue: "`2`", purpose: "Schema version for normalized artifacts.", mode: "autogen" }
];

const sourceFields = [
  { key: "kind", required: "Yes", purpose: "Source type: api, db, event, file, cache, input.", mode: "manual-required" },
  { key: "target", required: "Yes", purpose: "The operation or table (e.g., identity.GetUser).", mode: "manual-required" },
  { key: "path", required: "Yes", purpose: "Field path in the source response (e.g., response.id).", mode: "manual-required" },
  { key: "scope", required: "No", purpose: "Override scope for this source: internal, cross_repo, external.", mode: "defaulted" },
  { key: "contract", required: "Yes", purpose: "Reference to the contract artifact.", mode: "manual-required" },
  { key: "provider", required: "External only", purpose: "Third-party provider ID.", mode: "manual-optional" },
  { key: "as_of", required: "External only", purpose: "Snapshot date (YYYY-MM-DD).", mode: "manual-optional" },
  { key: "upstream_system", required: "No", purpose: "System ID if different from the annotation's `from`.", mode: "manual-optional" }
];

const overrideKeys = [
  { key: "field_id", required: "Yes", defaultValue: "None", purpose: "Field identity receiving the temporary exception.", mode: "manual-required" },
  { key: "change_type", required: "Yes", defaultValue: "None", purpose: "Drift type (or `*`) covered by the override.", mode: "manual-required" },
  { key: "expires", required: "Yes", defaultValue: "None", purpose: "UTC date when override stops applying.", mode: "manual-required" },
  { key: "reason", required: "Yes", defaultValue: "None", purpose: "Human-readable justification for the override.", mode: "manual-required" },
  { key: "ticket", required: "No", defaultValue: "None", purpose: "Optional issue/change ticket id.", mode: "recommended" }
];

const serviceRegistryKeys = [
  { key: "id", required: "Yes", purpose: "Stable system identifier. Use `parent:child` for internal subsystems.", mode: "manual-required" },
  { key: "name", required: "Yes", purpose: "Human-readable system name.", mode: "manual-required" },
  { key: "owner_team", required: "Yes", purpose: "Owning team/owner label.", mode: "manual-required" },
  { key: "runbook_url", required: "No", purpose: "Optional runbook URL for responders.", mode: "manual-optional" },
  { key: "doc_root", required: "No", purpose: "Optional root URL for service docs.", mode: "manual-optional" },
  { key: "flows", required: "No", purpose: "Flow IDs this service participates in.", mode: "recommended" },
  { key: "escalation", required: "No", purpose: "Ordered escalation contacts for this system.", mode: "recommended" },
  { key: "escalation[].channel", required: "No", purpose: "How responders are reached.", mode: "recommended" },
  { key: "escalation[].name", required: "No", purpose: "Contact display name.", mode: "recommended" },
  { key: "escalation[].role", required: "No", purpose: "Escalation role (primary/secondary/vendor/etc).", mode: "recommended" }
];

const flowRegistryKeys = [
  { key: "strict_flows[].id", required: "Yes", purpose: "Stable flow ID used by service memberships.", mode: "manual-required" },
  { key: "strict_flows[].name", required: "Yes", purpose: "Human-readable flow name.", mode: "manual-required" },
  { key: "strict_flows[].level", required: "Yes", purpose: "Numeric tier level (org-defined scale).", mode: "manual-required" },
  { key: "strict_flows[].owner", required: "No", purpose: "Flow owner label.", mode: "recommended" },
  { key: "strict_flows[].business_risk", required: "No", purpose: "Organization-managed risk code token.", mode: "recommended" }
];

const modeMeta = {
  defaulted: { label: "Defaulted", className: "anno-chip-defaulted" },
  autogen: { label: "Auto-inferred", className: "anno-chip-autogen" },
  recommended: { label: "Recommended", className: "anno-chip-recommended" },
  "manual-required": { label: "Required", className: "anno-chip-manual-required" },
  "manual-optional": { label: "Optional", className: "anno-chip-manual-optional" }
};
---

<MainLayout title="Annotations | Stricture" description="Guide to Stricture lineage annotations: what you annotate, the minimal format, and a complete key reference.">
  <section class="card">
    <p class="kicker">Docs</p>
    <h1>Stricture annotation guide and reference</h1>
    <p class="lead">
      The simplest annotation is <code>// strict-source: ServiceName</code>. Everything else is auto-inferred.
    </p>
    <p class="muted">
      Scope: lineage authoring (inline annotations, sidecar files, service + flow registries, and temporary overrides).
    </p>
    <div class="anno-legend">
      {Object.values(modeMeta).map((mode) => (
        <span class={`anno-chip ${mode.className}`}>{mode.label}</span>
      ))}
    </div>
    <p class="muted">Recommended fields can be promoted to required by policy packs.</p>
  </section>

  <section class="card">
    <h2>Quick example</h2>
    <p>Sidecar file (<code>strict-lineage.yml</code>):</p>
    <pre><code>{`service: user-service
version: v2026.02

upstream:
  Identity:
    contract: git+https://github.com/acme/identity//openapi.yaml
    scope: cross_repo`}</code></pre>
    <p>Inline annotation:</p>
    <pre><code>{`// strict-source: Identity
UserID int \`json:"user_id"\``}</code></pre>
    <p>That's it. The field path, source version, contract, scope, owner, escalation, and 10+ more fields are all inferred automatically.</p>
  </section>

  <section class="card">
    <h2>What gets annotated (and why)</h2>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Object</th>
            <th>Where</th>
            <th>Syntax</th>
            <th>Why it exists</th>
          </tr>
        </thead>
        <tbody>
          {objectRows.map((row) => (
            <tr>
              <td>{row.object}</td>
              <td>{row.where}</td>
              <td><code>{row.syntax}</code></td>
              <td>{row.why}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Annotation keys (what you write)</h2>
    <p class="muted">
      Only <code>from</code> is required. Add qualifiers only when overriding defaults.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {annotationKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td><code>{item.defaultValue}</code></td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Auto-inferred keys (never write these)</h2>
    <p class="muted">
      These are derived automatically from code context, sidecar files, and service registries.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Default / Source</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {autoInferredKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Source entry fields (multi-source annotations)</h2>
    <p class="muted">
      Used in <code>sources:</code> blocks when a field has multiple upstream sources.
    </p>
    <pre><code>{`// strict-source:
//   from: Profile v3
//   merge: priority
//   sources:
//     - kind: api
//       target: identity.GetUser
//       path: response.user
//       scope: cross_repo
//       contract: git+https://github.com/acme/identity//openapi.yaml@f00d`}</code></pre>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Field</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {sourceFields.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Temporary override keys</h2>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {overrideKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Service registry keys</h2>
    <p class="muted">
      Defined in a registry file (e.g., <code>.stricture/strict-lineage-systems.yaml</code>), not inline.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {serviceRegistryKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Flow registry keys</h2>
    <p class="muted">
      Flow catalogs define business-critical tiers for policy gating.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {flowRegistryKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Policy packs can change required/default behavior</h2>
    <p class="muted">
      Teams can keep base annotations lightweight, then enforce stricter org rules through a single policy URL. Repo binding in <code>.stricture.yml</code>:
    </p>
    <pre><code>{`stricture_policy_url: https://policies.example.com/stricture/strict-policy.yaml
stricture_policy_sha256: <optional_sha256_pin>`}</code></pre>
    <p class="muted">CI/CD enforcement pattern:</p>
    <pre><code>{`strict policy verify-ref \\
  --config .stricture.yml \\
  --expected-url-env STRICTURE_POLICY_URL`}</code></pre>
  </section>

  <section class="card">
    <h2>Related docs</h2>
    <ul>
      <li><a href="/getting-started">Getting Started</a></li>
      <li><a href="/annotation-quality">Annotation Quality Guide</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/data-lineage-annotations.md" target="_blank" rel="noopener noreferrer">Canonical annotation spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/LINEAGE-AUTOMATION-SPEC.md" target="_blank" rel="noopener noreferrer">Automation/defaults spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/POLICY-PACK-SPEC.md" target="_blank" rel="noopener noreferrer">Policy pack spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/POLICY-CLI-CONTRACT.md" target="_blank" rel="noopener noreferrer">Policy CLI contract (GitHub)</a></li>
    </ul>
  </section>
</MainLayout>
