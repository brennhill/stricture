---
import MainLayout from "../layouts/MainLayout.astro";

const objectRows = [
  {
    object: "Field lineage annotation",
    where: "Code comments near emit/transform logic",
    reference: "strict:source",
    syntax: "stricture-source",
    why: "Defines per-field provenance, ownership, and drift semantics."
  },
  {
    object: "Source edge entry",
    where: "Inside `sources=` on a field annotation",
    reference: "strict:source-edge",
    syntax: "kind:target#path@scope?contract_ref=...",
    why: "Defines the upstream contract edge used for blast-radius tracing."
  },
  {
    object: "Service registry record",
    where: "`lineage-systems.yml` (or equivalent registry file)",
    reference: "strict:systems[]",
    syntax: "systems[] objects",
    why: "Defines service-level ownership, runbooks/docs, escalation defaults, and flow memberships."
  },
  {
    object: "Flow registry catalog",
    where: "Top-level in `lineage-systems.yml`",
    reference: "strict:flows[]",
    syntax: "'strict:flows' objects",
    why: "Defines named business flows and numeric tier levels for policy gating."
  },
  {
    object: "Temporary lineage override",
    where: "Code comments during migration windows",
    reference: "strict:lineage-override",
    syntax: "stricture-lineage-override",
    why: "Allows time-bounded exceptions with explicit reason and expiry."
  }
];

const sourceKeys = [
  { key: "annotation_schema_version", required: "No", defaultValue: "`1`", purpose: "Schema version for normalized artifacts.", mode: "defaulted" },
  { key: "break_policy", required: "No", defaultValue: "`strict`", purpose: "Compatibility policy used for drift severity.", mode: "defaulted" },
  { key: "confidence", required: "No", defaultValue: "`declared`", purpose: "How trusted/inferred the mapping is.", mode: "defaulted" },
  { key: "contract_test_id", required: "No", defaultValue: "`ci://contracts/<source_system_slug>/<field_id>`", purpose: "Reference to contract test coverage.", mode: "defaulted" },
  { key: "data_classification", required: "No", defaultValue: "`internal`", purpose: "Data sensitivity classification.", mode: "recommended" },
  { key: "escalation", required: "No", defaultValue: "`slack:#<source_system_slug>-oncall`", purpose: "Escalation channel for incidents.", mode: "defaulted" },
  { key: "field", required: "Yes* (helper or manual)", defaultValue: "Derived from code/schema path; fallback from `field_id`", purpose: "Dot path emitted by the API contract.", mode: "autogen" },
  { key: "field_id", required: "Yes*", defaultValue: "Derived from `field`; helper can auto-generate", purpose: "Stable field identity slug.", mode: "autogen" },
  { key: "flow", required: "No", defaultValue: "`from @<source_system> mapped @self`", purpose: "Human-readable flow summary.", mode: "defaulted" },
  { key: "introduced_at", required: "No", defaultValue: "`1970-01-01`", purpose: "First-known introduction date.", mode: "autogen" },
  { key: "merge_strategy", required: "No", defaultValue: "`single_source` or `priority`", purpose: "Merge policy for multi-source inputs.", mode: "defaulted" },
  { key: "min_supported_source_version", required: "No", defaultValue: "`source_version`", purpose: "Minimum upstream version considered compatible.", mode: "defaulted" },
  { key: "note", required: "No", defaultValue: "`defaulted_by=stricture`", purpose: "Freeform implementation note.", mode: "defaulted" },
  { key: "owner", required: "No", defaultValue: "`team.<source_system_slug>`", purpose: "Owning team for this field contract.", mode: "defaulted" },
  { key: "renamed_from", required: "No", defaultValue: "None", purpose: "Previous field identity for intentional migrations.", mode: "manual-optional" },
  { key: "source_system", required: "Yes (helper/server or manual)", defaultValue: "Derived from repo/service mapping when strict:server_url is configured", purpose: "Primary producing system/service.", mode: "autogen" },
  { key: "source_version", required: "Yes (helper or manual)", defaultValue: "Derived from source contract ref/commit when available", purpose: "Producer version for this mapping.", mode: "autogen" },
  { key: "sources", required: "Yes (helper or manual)", defaultValue: "Helper-inferred from AST + contracts", purpose: "One or more upstream source edge refs.", mode: "autogen" },
  { key: "sunset_at", required: "No", defaultValue: "None", purpose: "Optional deprecation/removal target date.", mode: "manual-optional" },
  { key: "transform_type", required: "No", defaultValue: "`passthrough`", purpose: "Transform operation type for this field.", mode: "defaulted" }
];

const sourceQueryKeys = [
  { key: "as_of", required: "Conditional", defaultValue: "Required for `@external` scope (helper can stamp run-date)", purpose: "Snapshot date (`YYYY-MM-DD`) for external providers.", mode: "autogen" },
  { key: "contract_ref", required: "Yes", defaultValue: "Helper can derive from OpenAPI/AsyncAPI/proto pointers", purpose: "Canonical contract/spec pointer for the source edge.", mode: "autogen" },
  { key: "provider_id", required: "Conditional", defaultValue: "Required for `@external`; helper can map from provider catalog", purpose: "External provider identifier.", mode: "autogen" },
  { key: "upstream_system", required: "No", defaultValue: "Helper-inferred from source target/service map", purpose: "Optional explicit upstream service/system id.", mode: "autogen" }
];

const overrideKeys = [
  { key: "change_type", required: "Yes", defaultValue: "None", purpose: "Drift type (or `*`) covered by the override.", mode: "manual-required" },
  { key: "expires", required: "Yes", defaultValue: "None", purpose: "UTC date when override stops applying.", mode: "manual-required" },
  { key: "field_id", required: "Yes", defaultValue: "None", purpose: "Field identity receiving the temporary exception.", mode: "manual-required" },
  { key: "reason", required: "Yes", defaultValue: "None", purpose: "Human-readable justification for the override.", mode: "manual-required" },
  { key: "ticket", required: "No", defaultValue: "None", purpose: "Optional issue/change ticket id.", mode: "recommended" }
];

const serviceRegistryKeys = [
  { key: "id", required: "Yes (helper/server or manual)", defaultValue: "Derived from repo/service identity when strict:server_url is configured", purpose: "Stable system identifier. Use `parent` for topology and `parent:child` for internal subsystems.", mode: "autogen" },
  { key: "name", required: "Yes", defaultValue: "None", purpose: "Human-readable system name.", mode: "manual-required" },
  { key: "owner_team", required: "Yes", defaultValue: "None", purpose: "Owning team slug.", mode: "manual-required" },
  { key: "runbook_url", required: "No", defaultValue: "None", purpose: "Optional runbook URL used by responders.", mode: "manual-optional" },
  { key: "doc_root", required: "No", defaultValue: "None", purpose: "Optional root URL for external/internal service docs.", mode: "manual-optional" },
  { key: "flows", required: "No (recommended for multi-service policy)", defaultValue: "None", purpose: "Flow IDs this service participates in.", mode: "recommended" },
  { key: "escalation", required: "No (policy can require)", defaultValue: "None", purpose: "Ordered escalation contacts for this system.", mode: "recommended" },
  { key: "escalation[].channel", required: "No (policy can require)", defaultValue: "None", purpose: "How responders are reached.", mode: "recommended" },
  { key: "escalation[].name", required: "No (policy can require)", defaultValue: "None", purpose: "Contact display name.", mode: "recommended" },
  { key: "escalation[].role", required: "No (policy can require)", defaultValue: "None", purpose: "Escalation role (primary/secondary/vendor/etc).", mode: "recommended" }
];

const flowRegistryKeys = [
  { key: "strict:flows[].id", required: "Yes", defaultValue: "None", purpose: "Stable flow ID used by service memberships.", mode: "manual-required" },
  { key: "strict:flows[].name", required: "Yes", defaultValue: "None", purpose: "Human-readable flow name.", mode: "manual-required" },
  { key: "strict:flows[].level", required: "Yes", defaultValue: "None", purpose: "Numeric tier level (org-defined scale).", mode: "manual-required" },
  { key: "strict:flows[].owner", required: "No", defaultValue: "None", purpose: "Owning team for business flow governance.", mode: "recommended" },
  { key: "strict:flows[].business_risk", required: "No", defaultValue: "None", purpose: "Organization-managed risk code token used by policy (for example order_loss).", mode: "recommended" }
];

const modeMeta = {
  defaulted: { label: "Defaulted", className: "anno-chip-defaulted" },
  autogen: { label: "Auto-gen", className: "anno-chip-autogen" },
  recommended: { label: "Strongly recommended", className: "anno-chip-recommended" },
  "manual-required": { label: "Manual + required", className: "anno-chip-manual-required" },
  "manual-optional": { label: "Manual + optional", className: "anno-chip-manual-optional" }
};
---

<MainLayout title="Annotations | Stricture" description="Clear guide to what Stricture annotates, why it matters, and an alphabetical annotation reference with required/default behavior.">
  <section class="card">
    <p class="kicker">Docs</p>
    <h1>Stricture annotation guide and reference</h1>
    <p class="lead">
      This page answers three questions: what objects you annotate, why each one exists, and exactly which keys are required vs defaulted.
    </p>
    <p class="muted">
      Scope: lineage authoring (`stricture-source`, source edges, service + flow registries, and temporary lineage overrides).
    </p>
    <p class="muted">
      `strict:*` labels on this page are reference handles for docs and tooling UX; parser syntax is shown separately in the syntax column.
    </p>
    <p class="muted">Backward-compatible alias handles using `stricture:*` remain accepted in docs/tooling.</p>
    <div class="anno-legend">
      {Object.values(modeMeta).map((mode) => (
        <span class={`anno-chip ${mode.className}`}>{mode.label}</span>
      ))}
    </div>
    <p class="muted">Recommended fields can be promoted to required by policy packs.</p>
    <p class="muted">When part of a multi-service ecosystem, use <code>strict:server_url</code> so Autogen fields resolve from shared service/policy context.</p>
    <p class="muted">Hierarchy convention: <code>system-id</code> for ecosystem nodes and <code>system-id:subsystem-id</code> for internals; no new annotation key required.</p>
  </section>

  <section class="card">
    <h2>What gets annotated (and why)</h2>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Object</th>
            <th>Where</th>
            <th>Stricture reference</th>
            <th>Syntax</th>
            <th>Why it exists</th>
          </tr>
        </thead>
        <tbody>
          {objectRows.map((row) => (
            <tr>
              <td>{row.object}</td>
              <td>{row.where}</td>
              <td><code>{row.reference}</code></td>
              <td><code>{row.syntax}</code></td>
              <td>{row.why}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Field annotation keys (A-Z)</h2>
    <p class="muted">
      * `field` or `field_id` must be present. In practice, helper/server workflows should auto-generate both whenever resolvable from code/schema context.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {sourceKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td><code>{item.defaultValue}</code></td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Source edge query keys (A-Z)</h2>
    <p class="muted">
      Source grammar: <code>kind:target#path[@scope[!as_of]][?contract_ref=&lt;ref&gt;&amp;provider_id=&lt;id&gt;&amp;upstream_system=&lt;id&gt;]</code>
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Query key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default / Rule</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {sourceQueryKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Temporary override keys (A-Z)</h2>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {overrideKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Service registry keys (A-Z)</h2>
    <p class="muted">
      Service-level ownership, runbooks/docs, escalation, and flow memberships are defined in a registry file (for example `lineage-systems.yml`), not inline in each handler.
    </p>
    <p class="muted">
      If a `strict:server_url` is configured, helper/server workflows can bootstrap service IDs automatically and register them centrally.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {serviceRegistryKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Flow registry keys (A-Z)</h2>
    <p class="muted">
      Flow catalogs are top-level registry metadata (`'strict:flows'`) used by policy to map drift findings to business-critical tiers.
    </p>
    <p class="muted">
      <code>business_risk</code> is an organization-managed token (for example <code>order_loss</code>), not a built-in global enum.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {flowRegistryKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Policy packs can change required/default behavior</h2>
    <p class="muted">
      Teams can keep base annotations lightweight, then enforce stricter org rules through a single policy URL. Repo binding:
    </p>
    <pre><code>{`'strict:policy_url': https://policies.example.com/stricture/prod.yml
'strict:policy_sha256': <optional_sha256_pin>`}</code></pre>
    <p class="muted">CI/CD enforcement pattern:</p>
    <pre><code>{`stricture policy verify-ref \
  --config .stricture.yml \
  --expected-url-env STRICTURE_POLICY_URL`}</code></pre>
    <p class="muted">Example policy pack at that URL:</p>
    <pre><code>{`schema_version: 1
policy_id: strict:policy

lineage:
  require:
    field_keys:
      - owner
      - escalation
    system_registry_keys:
      - escalation
      - escalation[].role
      - escalation[].name
      - escalation[].channel
      - runbook_url
      - doc_root
  defaults:
    escalation: pagerduty:platform-oncall
    break_policy: strict
  findings:
    require_downstream_impact: true
    flow_criticality:
      enabled: true
      level_direction: lower_is_more_critical
      fail_on_level: 1
      critical_flow_ids:
        - checkout
      critical_flow_block_reason: "Risk of order loss"`}</code></pre>
  </section>

  <section class="card">
    <h2>How tool-assisted authoring makes this easier</h2>
    <ul>
      <li><strong>`source_system`</strong>: helper derives service identity from repo/service mapping; prefer <code>strict:server_url</code> in multi-service environments.</li>
      <li><strong>`source_version`</strong>: helper resolves from contract source ref (repo tag/commit) so humans do not bump it manually every PR.</li>
      <li><strong>`sources`</strong>: helper infers edge candidates from AST + contract schemas and writes normalized refs.</li>
      <li><strong>`contract_ref`</strong>: helper reuses OpenAPI/AsyncAPI/proto pointers already present in repo/config.</li>
      <li><strong>`provider_id` + `as_of`</strong>: helper fills from provider registry and run timestamp for external sources.</li>
      <li><strong>Manual override remains</strong>: engineers can still pin or override values when migration windows need explicit intent.</li>
    </ul>
  </section>

  <section class="card">
    <h2>Related docs</h2>
    <ul>
      <li><a href="/getting-started">Getting Started</a></li>
      <li><a href="/annotation-quality">Annotation Quality Guide</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/data-lineage-annotations.md" target="_blank" rel="noopener noreferrer">Canonical annotation spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/LINEAGE-AUTOMATION-SPEC.md" target="_blank" rel="noopener noreferrer">Automation/defaults spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/POLICY-PACK-SPEC.md" target="_blank" rel="noopener noreferrer">Policy pack spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/POLICY-CLI-CONTRACT.md" target="_blank" rel="noopener noreferrer">Policy CLI contract (GitHub)</a></li>
    </ul>
  </section>
</MainLayout>
