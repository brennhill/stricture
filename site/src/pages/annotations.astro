---
import MainLayout from "../layouts/MainLayout.astro";

const objectRows = [
  {
    object: "Field lineage annotation",
    where: "Code comments near emit/transform logic",
    reference: "stricture:source",
    syntax: "stricture-source",
    why: "Defines per-field provenance, ownership, and drift semantics."
  },
  {
    object: "Source edge entry",
    where: "Inside `sources=` on a field annotation",
    reference: "stricture:source-edge",
    syntax: "kind:target#path@scope?contract_ref=...",
    why: "Defines the upstream contract edge used for blast-radius tracing."
  },
  {
    object: "Service registry record",
    where: "`lineage-systems.yml` (or equivalent registry file)",
    reference: "stricture:systems[]",
    syntax: "systems[] objects",
    why: "Defines service-level ownership and escalation defaults."
  },
  {
    object: "Temporary lineage override",
    where: "Code comments during migration windows",
    reference: "stricture:lineage-override",
    syntax: "stricture-lineage-override",
    why: "Allows time-bounded exceptions with explicit reason and expiry."
  }
];

const sourceKeys = [
  { key: "annotation_schema_version", required: "No", defaultValue: "`1`", purpose: "Schema version for normalized artifacts.", mode: "defaulted" },
  { key: "break_policy", required: "No", defaultValue: "`strict`", purpose: "Compatibility policy used for drift severity.", mode: "defaulted" },
  { key: "confidence", required: "No", defaultValue: "`declared`", purpose: "How trusted/inferred the mapping is.", mode: "defaulted" },
  { key: "contract_test_id", required: "No", defaultValue: "`ci://contracts/<source_system_slug>/<field_id>`", purpose: "Reference to contract test coverage.", mode: "defaulted" },
  { key: "data_classification", required: "No", defaultValue: "`internal`", purpose: "Data sensitivity classification.", mode: "recommended" },
  { key: "escalation", required: "No", defaultValue: "`slack:#<source_system_slug>-oncall`", purpose: "Escalation channel for incidents.", mode: "defaulted" },
  { key: "field", required: "Yes*", defaultValue: "Derived from `field_id` when omitted", purpose: "Dot path emitted by the API contract.", mode: "manual-required" },
  { key: "field_id", required: "Yes*", defaultValue: "Derived from `field`; helper can auto-generate", purpose: "Stable field identity slug.", mode: "autogen" },
  { key: "flow", required: "No", defaultValue: "`from @<source_system> mapped @self`", purpose: "Human-readable flow summary.", mode: "defaulted" },
  { key: "introduced_at", required: "No", defaultValue: "`1970-01-01`", purpose: "First-known introduction date.", mode: "autogen" },
  { key: "merge_strategy", required: "No", defaultValue: "`single_source` or `priority`", purpose: "Merge policy for multi-source inputs.", mode: "defaulted" },
  { key: "min_supported_source_version", required: "No", defaultValue: "`source_version`", purpose: "Minimum upstream version considered compatible.", mode: "defaulted" },
  { key: "note", required: "No", defaultValue: "`defaulted_by=stricture`", purpose: "Freeform implementation note.", mode: "defaulted" },
  { key: "owner", required: "No", defaultValue: "`team.<source_system_slug>`", purpose: "Owning team for this field contract.", mode: "defaulted" },
  { key: "renamed_from", required: "No", defaultValue: "None", purpose: "Previous field identity for intentional migrations.", mode: "manual-optional" },
  { key: "source_system", required: "Yes", defaultValue: "None", purpose: "Primary producing system/service.", mode: "manual-required" },
  { key: "source_version", required: "Yes", defaultValue: "None", purpose: "Producer version for this mapping.", mode: "manual-required" },
  { key: "sources", required: "Yes", defaultValue: "None", purpose: "One or more upstream source edge refs.", mode: "manual-required" },
  { key: "sunset_at", required: "No", defaultValue: "None", purpose: "Optional deprecation/removal target date.", mode: "manual-optional" },
  { key: "transform_type", required: "No", defaultValue: "`passthrough`", purpose: "Transform operation type for this field.", mode: "defaulted" }
];

const sourceQueryKeys = [
  { key: "as_of", required: "Conditional", defaultValue: "Required for `@external` scope", purpose: "Snapshot date (`YYYY-MM-DD`) for external providers.", mode: "manual-required" },
  { key: "contract_ref", required: "Yes", defaultValue: "None", purpose: "Canonical contract/spec pointer for the source edge.", mode: "manual-required" },
  { key: "provider_id", required: "Conditional", defaultValue: "Required for `@external`; forbidden otherwise", purpose: "External provider identifier.", mode: "manual-required" },
  { key: "upstream_system", required: "No", defaultValue: "None", purpose: "Optional explicit upstream service/system id.", mode: "manual-optional" }
];

const overrideKeys = [
  { key: "change_type", required: "Yes", defaultValue: "None", purpose: "Drift type (or `*`) covered by the override.", mode: "manual-required" },
  { key: "expires", required: "Yes", defaultValue: "None", purpose: "UTC date when override stops applying.", mode: "manual-required" },
  { key: "field_id", required: "Yes", defaultValue: "None", purpose: "Field identity receiving the temporary exception.", mode: "manual-required" },
  { key: "reason", required: "Yes", defaultValue: "None", purpose: "Human-readable justification for the override.", mode: "manual-required" },
  { key: "ticket", required: "No", defaultValue: "None", purpose: "Optional issue/change ticket id.", mode: "recommended" }
];

const serviceRegistryKeys = [
  { key: "id", required: "Yes", defaultValue: "None", purpose: "Stable system identifier used in lineage edges.", mode: "manual-required" },
  { key: "name", required: "Yes", defaultValue: "None", purpose: "Human-readable system name.", mode: "manual-required" },
  { key: "owner_team", required: "Yes", defaultValue: "None", purpose: "Owning team slug.", mode: "manual-required" },
  { key: "escalation", required: "No (policy can require)", defaultValue: "None", purpose: "Ordered escalation contacts for this system.", mode: "recommended" },
  { key: "escalation[].channel", required: "No (policy can require)", defaultValue: "None", purpose: "How responders are reached.", mode: "recommended" },
  { key: "escalation[].name", required: "No (policy can require)", defaultValue: "None", purpose: "Contact display name.", mode: "recommended" },
  { key: "escalation[].role", required: "No (policy can require)", defaultValue: "None", purpose: "Escalation role (primary/secondary/vendor/etc).", mode: "recommended" }
];

const modeMeta = {
  defaulted: { label: "Defaulted", className: "anno-chip-defaulted" },
  autogen: { label: "Auto-gen", className: "anno-chip-autogen" },
  recommended: { label: "Strongly recommended", className: "anno-chip-recommended" },
  "manual-required": { label: "Manual + required", className: "anno-chip-manual-required" },
  "manual-optional": { label: "Manual + optional", className: "anno-chip-manual-optional" }
};
---

<MainLayout title="Annotations | Stricture" description="Clear guide to what Stricture annotates, why it matters, and an alphabetical annotation reference with required/default behavior.">
  <section class="card">
    <p class="kicker">Docs</p>
    <h1>Stricture annotation guide and reference</h1>
    <p class="lead">
      This page answers three questions: what objects you annotate, why each one exists, and exactly which keys are required vs defaulted.
    </p>
    <p class="muted">
      Scope: lineage authoring (`stricture-source`, source edges, service registry, and temporary lineage overrides).
    </p>
    <p class="muted">
      `stricture:*` labels on this page are reference handles for docs and tooling UX; parser syntax is shown separately in the syntax column.
    </p>
    <div class="anno-legend">
      {Object.values(modeMeta).map((mode) => (
        <span class={`anno-chip ${mode.className}`}>{mode.label}</span>
      ))}
    </div>
    <p class="muted">Recommended fields can be promoted to required by policy packs.</p>
  </section>

  <section class="card">
    <h2>What gets annotated (and why)</h2>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Object</th>
            <th>Where</th>
            <th>Stricture reference</th>
            <th>Syntax</th>
            <th>Why it exists</th>
          </tr>
        </thead>
        <tbody>
          {objectRows.map((row) => (
            <tr>
              <td>{row.object}</td>
              <td>{row.where}</td>
              <td><code>{row.reference}</code></td>
              <td><code>{row.syntax}</code></td>
              <td>{row.why}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Field annotation keys (A-Z)</h2>
    <p class="muted">
      * `field` or `field_id` must be present. Source comments are minimal-authoring; normalized artifacts always emit explicit canonical keys.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {sourceKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td><code>{item.defaultValue}</code></td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Source edge query keys (A-Z)</h2>
    <p class="muted">
      Source grammar: <code>kind:target#path[@scope[!as_of]][?contract_ref=&lt;ref&gt;&amp;provider_id=&lt;id&gt;&amp;upstream_system=&lt;id&gt;]</code>
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Query key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default / Rule</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {sourceQueryKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Temporary override keys (A-Z)</h2>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {overrideKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Service registry keys (A-Z)</h2>
    <p class="muted">
      Service-level ownership and escalation are defined in a registry file (for example `lineage-systems.yml`), not inline in each handler.
    </p>
    <div class="compare-table-wrap">
      <table class="compare-table">
        <thead>
          <tr>
            <th>Key</th>
            <th>Mode</th>
            <th>Required</th>
            <th>Default</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          {serviceRegistryKeys.map((item) => (
            <tr>
              <td><code>{item.key}</code></td>
              <td><span class={`anno-chip ${modeMeta[item.mode].className}`}>{modeMeta[item.mode].label}</span></td>
              <td>{item.required}</td>
              <td>{item.defaultValue}</td>
              <td>{item.purpose}</td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Policy packs can change required/default behavior</h2>
    <p class="muted">
      Teams can keep base annotations lightweight, then enforce stricter org rules through a single policy URL. Repo binding:
    </p>
    <pre><code>{`'strict:policy_url': https://policies.example.com/stricture/prod.yml
'strict:policy_sha256': <optional_sha256_pin>`}</code></pre>
    <p class="muted">Example policy pack at that URL:</p>
    <pre><code>{`schema_version: 1
policy_id: strict:policy

lineage:
  require:
    field_keys:
      - owner
      - escalation
    system_registry_keys:
      - escalation
      - escalation[].role
      - escalation[].name
      - escalation[].channel
  defaults:
    escalation: pagerduty:platform-oncall
    break_policy: strict
  severity_overrides:
    missing_escalation: high`}</code></pre>
  </section>

  <section class="card">
    <h2>Related docs</h2>
    <ul>
      <li><a href="/getting-started">Getting Started</a></li>
      <li><a href="/annotation-quality">Annotation Quality Guide</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/data-lineage-annotations.md" target="_blank" rel="noopener noreferrer">Canonical annotation spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/LINEAGE-AUTOMATION-SPEC.md" target="_blank" rel="noopener noreferrer">Automation/defaults spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/POLICY-PACK-SPEC.md" target="_blank" rel="noopener noreferrer">Policy pack spec (GitHub)</a></li>
      <li><a href="https://github.com/brennhill/stricture/blob/main/docs/POLICY-CLI-CONTRACT.md" target="_blank" rel="noopener noreferrer">Policy CLI contract (GitHub)</a></li>
    </ul>
  </section>
</MainLayout>
