---
import MainLayout from "../layouts/MainLayout.astro";
import { Code } from "astro:components";

export const prerender = true;

const serviceRegistrySnippet = String.raw`'strict:flows':
  - id: checkout
    name: Checkout
    level: 1
    owner: Payments platform team
    business_risk: order_loss

systems:
  - id: CheckoutGateway
    name: Checkout Gateway
    owner_team: Payments platform team
    runbook_url: https://runbooks.example.com/checkout-gateway
    doc_root: https://docs.example.com/checkout-gateway
    flows: [checkout]
    escalation:
      - role: primary
        name: Payments Oncall
        channel: pagerduty:payments-oncall
  - id: CheckoutGateway:API
    name: Checkout Gateway API (Java)
    owner_team: Payments platform team
    runbook_url: https://runbooks.example.com/checkout-gateway-api
    doc_root: https://docs.example.com/checkout-gateway-api
    flows: [checkout]
  - id: CheckoutGateway:web-ui
    name: Checkout Gateway Web UI (Node.js)
    owner_team: Payments platform team
    runbook_url: https://runbooks.example.com/checkout-gateway-web-ui
    doc_root: https://docs.example.com/checkout-gateway-web-ui
    flows: [checkout]
`;

const javaSnippet = String.raw`@RestController
@RequestMapping("/v1/checkout")
@Tag(name = "Checkout API") // re-used by Stricture: OpenAPI surface docs
class CheckoutController {

  @WithSpan("checkout.authorize") // re-used by Stricture: OpenTelemetry span context
  @Operation(summary = "Authorize payment")
  @GetMapping("/authorize/{cartId}")
  PaymentResponse authorize(@PathVariable String cartId) {
    // stricture-source field=response.checkout.payment_status source_system=CheckoutGateway:API
    // source_version=v2026.08
    // sources=api:PaymentCore.Authorize#response.payment_status@cross_repo?contract_ref=git+https://github.com/acme/payment-core//openapi.yaml@9a12
    // re-used by Stricture, batteries included: OpenAPI + OTel + strict provenance
    return checkoutService.authorize(cartId);
  }
}
`;

const protobufSnippet = String.raw`syntax = "proto3";

package checkout.v1;

import "google/api/annotations.proto";

service CheckoutService {
  rpc Authorize(AuthorizeRequest) returns (AuthorizeResponse) {
    option (google.api.http) = { get: "/v1/checkout/authorize/{cart_id}" };
  }
}

message AuthorizeResponse {
  // Stricture annotations attach to concrete output fields.
  // re-used by Stricture: Buf/proto schema docs and field identity
  // stricture-source field=response.checkout.payment_status source_system=CheckoutGateway:API
  // source_version=v2026.08
  // sources=api:PaymentCore.Authorize#response.payment_status@cross_repo?contract_ref=buf://acme/payment-core/payment/v1/payment.proto
  string payment_status = 1;
}
`;

const goSnippet = String.raw`type CheckoutResponse struct {
  // Keep Stricture field annotations near response emit/transform logic.
  PaymentStatus string ` + "`json:\"payment_status\"`" + `
}

func (h *Handler) Authorize(w http.ResponseWriter, r *http.Request) {
  ctx, span := h.tracer.Start(r.Context(), "checkout.authorize") // re-used by Stricture: OpenTelemetry trace
  defer span.End()

  // stricture-source field=response.checkout.payment_status source_system=CheckoutGateway:API
  // source_version=v2026.08
  // sources=api:PaymentCore.Authorize#response.payment_status@cross_repo?contract_ref=git+https://github.com/acme/payment-core//openapi.yaml@9a12
  // re-used by Stricture, batteries included: OTel + OpenAPI contract pointers
  resp := CheckoutResponse{PaymentStatus: "authorized"}
  _ = ctx
  json.NewEncoder(w).Encode(resp)
}
`;

const pythonSnippet = String.raw`from fastapi import FastAPI
from pydantic import BaseModel
from opentelemetry import trace

app = FastAPI(title="Checkout API")  # re-used by Stricture: OpenAPI generation
tracer = trace.get_tracer(__name__)

class CheckoutResponse(BaseModel):
    payment_status: str

@app.get("/v1/checkout/authorize/{cart_id}", response_model=CheckoutResponse)
def authorize(cart_id: str) -> CheckoutResponse:
    with tracer.start_as_current_span("checkout.authorize"):  # re-used by Stricture: OTel span
        # stricture-source field=response.checkout.payment_status source_system=CheckoutGateway:API
        # source_version=v2026.08
        # sources=api:PaymentCore.Authorize#response.payment_status@cross_repo?contract_ref=git+https://github.com/acme/payment-core//openapi.yaml@9a12
        # re-used by Stricture, batteries included: FastAPI OpenAPI + OTel + strict lineage
        return CheckoutResponse(payment_status="authorized")
`;

const nodeSnippet = String.raw`import express from "express";
import { trace } from "@opentelemetry/api";

const app = express();
const tracer = trace.getTracer("checkout-gateway");

/**
 * @openapi
 * /v1/checkout/authorize/{cartId}:
 *   get:
 *     summary: Authorize payment
 *     responses:
 *       "200":
 *         description: Checkout authorization
 */
app.get("/v1/checkout/authorize/:cartId", (req, res) => {
  tracer.startActiveSpan("checkout.authorize", (span) => { // re-used by Stricture: OTel
    // stricture-source field=response.checkout.payment_status source_system=CheckoutGateway:web-ui
    // source_version=v2026.08
    // sources=api:PaymentCore.Authorize#response.payment_status@cross_repo?contract_ref=git+https://github.com/acme/payment-core//openapi.yaml@9a12
    // re-used by Stricture, batteries included: OpenAPI JSDoc + OTel + strict lineage
    res.json({ payment_status: "authorized" });
    span.end();
  });
});
`;

const policyBindingSnippet = String.raw`# .stricture.yml
'strict:policy_url': https://policies.example.com/stricture/strict-policy.yaml
'strict:policy_sha256': <optional_sha256_pin>
'strict:server_url': https://stricture.example.com
`;

const policySnippet = String.raw`# .stricture/strict-policy.yaml
schema_version: 1
policy_id: production_standard # org-provided string; can be any useful value

lineage:
  findings:
    require_downstream_impact: true
    flow_criticality:
      enabled: true
      level_direction: lower_is_more_critical
      fail_on_level: 1
      critical_flow_ids: [checkout]
      critical_flow_block_reason: "Risk of order loss"
  require:
    system_registry_keys:
      - escalation
      - runbook_url
      - doc_root
`;

const examples = [
  {
    id: "java",
    tabLabel: "Java",
    title: "Java + OpenTelemetry + OpenAPI",
    description: "API subsystem is Java (`CheckoutGateway:API`) with field-level lineage near response emit logic.",
    lang: "java",
    code: javaSnippet,
  },
  {
    id: "proto",
    tabLabel: "Protobuf/Buf",
    title: "Protobuf + Buf",
    description: "Contracts stay in proto/buf, but Stricture annotations still attach at output field level and use the Java API subsystem as source.",
    lang: "proto",
    code: protobufSnippet,
  },
  {
    id: "go",
    tabLabel: "Go",
    title: "Golang + net/http + OTel",
    description: "Go example keeps Stricture annotations at field emit points; service-level owner/runbook/docs remain in strict:systems[].",
    lang: "go",
    code: goSnippet,
  },
  {
    id: "python",
    tabLabel: "Python",
    title: "Python + FastAPI + OTel",
    description: "FastAPI OpenAPI generation plus OTel tracing, with Stricture lineage comments on response fields.",
    lang: "python",
    code: pythonSnippet,
  },
  {
    id: "node",
    tabLabel: "Node/JavaScript",
    title: "Node.js + Express + OpenAPI JSDoc + OTel",
    description: "Web UI subsystem is Node.js (`CheckoutGateway:web-ui`) with field-level lineage on emitted response fields.",
    lang: "ts",
    code: nodeSnippet,
  },
];
---

<MainLayout
  title="Examples | Stricture"
  description="Practical Stricture annotation examples across Java, Protobuf/Buf, Go, Python, and Node.js with OpenAPI and OpenTelemetry integration."
>
  <section class="card">
    <p class="kicker">Examples</p>
    <h1>Strict annotations in real stacks</h1>
    <p class="lead">
      Use your existing framework metadata (OpenAPI, OpenTelemetry, protobuf/buf), then add strict lineage comments where fields are emitted or transformed.
    </p>
    <p class="muted">
      Pattern: keep service-level metadata in <code>strict:systems[]</code>, and API/field-level provenance in <code>stricture-source</code> comments.
    </p>
    <p class="muted">
      Repo layout convention: keep shared files under <code>.stricture/</code> (for example <code>.stricture/strict-lineage-systems.yaml</code>) and keep repo-level settings in <code>.stricture.yml</code>.
    </p>
  </section>

  <section class="card">
    <h2>Service-level annotations (registry)</h2>
    <p class="muted">
      This is where ownership, escalation, runbooks/docs, and flow tiers live. It is a shared registry file (for example <code>.stricture/strict-lineage-systems.yaml</code>), not inline code comments.
    </p>
    <p class="muted">
      <code>business_risk</code> is an org-managed risk code token (for example <code>order_loss</code>), not a global built-in enum in Stricture core.
    </p>
    <p class="muted">
      <code>owner_team</code> and flow <code>owner</code> are free-form strings (for example <code>Payments platform team</code> or <code>team.payments-platform</code>). No centralized team inventory is required by default.
    </p>
    <p class="muted">
      Flow tier is defined on the flow catalog row (<code>'strict:flows'[].level</code>) and services join that tier via <code>systems[].flows: [checkout]</code>.
    </p>
    <div class="code-shell">
      <Code code={serviceRegistrySnippet} lang="yaml" />
    </div>
  </section>

  <section class="card">
    <h2>Language examples (tabbed)</h2>
    <p class="muted">
      Same topology, different stack: API is Java (<code>CheckoutGateway:API</code>) and web UI is Node.js (<code>CheckoutGateway:web-ui</code>).
    </p>
    <div class="example-tabs" role="tablist" aria-label="Language examples">
      {examples.map((example, idx) => (
        <button
          type="button"
          class={`example-tab ${idx === 0 ? "is-active" : ""}`}
          data-example-tab={example.id}
          role="tab"
          aria-selected={idx === 0 ? "true" : "false"}
        >
          {example.tabLabel}
        </button>
      ))}
    </div>

    {examples.map((example, idx) => (
      <div
        class={`example-panel ${idx === 0 ? "is-active" : ""}`}
        data-example-panel={example.id}
        hidden={idx !== 0}
      >
        <h3 class="example-subhead">{example.title}</h3>
        <p class="muted">{example.description}</p>
        <div class="code-shell">
          <Code code={example.code} lang={example.lang} />
        </div>
      </div>
    ))}
  </section>

  <section class="card">
    <h2>Policy example (flow-tier gating)</h2>
    <p class="muted">
      Repo-level pointers go in <code>.stricture.yml</code>; policy content can live in <code>.stricture/strict-policy.yaml</code> (or remote URL).
      See the <a href="/policy">Policy Guide</a> for required/optional fields and best practices.
    </p>
    <div class="code-shell">
      <Code code={policyBindingSnippet} lang="yaml" />
    </div>
    <div class="code-shell">
      <Code code={policySnippet} lang="yaml" />
    </div>
    <p class="muted">
      Where checkout tier is declared: flow catalog sets <code>checkout level=1</code>; services bind themselves to checkout via <code>systems[].flows</code>; policy then gates with <code>flow_criticality.fail_on_level</code> and/or <code>critical_flow_ids</code>.
    </p>
  </section>
</MainLayout>

<script is:inline>
  (() => {
    const tabs = Array.from(document.querySelectorAll("[data-example-tab]"));
    const panels = Array.from(document.querySelectorAll("[data-example-panel]"));
    if (!tabs.length || !panels.length) return;

    const activate = (id) => {
      tabs.forEach((tab) => {
        const active = tab.dataset.exampleTab === id;
        tab.classList.toggle("is-active", active);
        tab.setAttribute("aria-selected", active ? "true" : "false");
      });
      panels.forEach((panel) => {
        const active = panel.dataset.examplePanel === id;
        panel.classList.toggle("is-active", active);
        panel.hidden = !active;
      });
    };

    tabs.forEach((tab) => {
      tab.addEventListener("click", () => activate(tab.dataset.exampleTab || ""));
    });
  })();
</script>

<style>
  .code-shell {
    border: 1px solid var(--line);
    border-radius: 12px;
    overflow: hidden;
    margin-top: 0.65rem;
  }

  .code-shell :global(pre.astro-code) {
    margin: 0;
    padding: 1rem;
    font-size: 0.79rem;
    line-height: 1.45;
    overflow-x: auto;
  }

  .example-subhead {
    margin: 0.8rem 0 0.3rem;
    font-size: 0.95rem;
  }

  .example-tabs {
    display: flex;
    flex-wrap: wrap;
    gap: 0.4rem;
    margin: 0.55rem 0 0.65rem;
  }

  .example-tab {
    border: 1px solid var(--line);
    border-radius: 999px;
    padding: 0.3rem 0.7rem;
    font-size: 0.8rem;
    background: #ffffff;
    color: var(--ink);
    cursor: pointer;
  }

  .example-tab.is-active {
    border-color: var(--brand);
    background: color-mix(in srgb, var(--brand) 12%, #ffffff);
    color: var(--brand-ink);
    font-weight: 600;
  }

  .example-panel {
    margin-top: 0.4rem;
  }
</style>
