# ci.yml — Full CI pipeline for Stricture.
#
# Runs on every push and PR. Enforces all development gates.
# If this pipeline passes, the code is ready to merge.

name: CI

on:
  push:
    branches: [main, next]
  pull_request:
    branches: [main, next]

permissions:
  contents: read

env:
  GO_VERSION: "1.22"
  GOLANGCI_LINT_VERSION: "v1.57"
  COVERAGE_THRESHOLD: 80

jobs:
  # ─── Stage 1: Fast checks (< 30s) ───────────────────────────
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: ${{ env.GOLANGCI_LINT_VERSION }}
          args: --timeout=5m

      - name: Check file headers
        run: |
          # Every .go file must start with "// filename.go — "
          FAILED=0
          while IFS= read -r file; do
            filename=$(basename "$file")
            expected="// ${filename} —"
            first_line=$(head -n1 "$file")
            if [[ "$first_line" != "$expected"* ]]; then
              echo "FAIL: $file — missing or incorrect file header"
              echo "  Expected: $expected ..."
              echo "  Got:      $first_line"
              FAILED=1
            fi
          done < <(find cmd internal pkg -name '*.go' -not -name '*_test.go' -not -name '*_generated.go' 2>/dev/null)
          exit $FAILED

      - name: Check file sizes (max 800 LOC)
        run: |
          FAILED=0
          while IFS= read -r file; do
            lines=$(wc -l < "$file")
            if [ "$lines" -gt 800 ]; then
              echo "FAIL: $file has $lines lines (max 800)"
              FAILED=1
            fi
          done < <(find cmd internal pkg -name '*.go' 2>/dev/null)
          exit $FAILED

      - name: Check no TODO without issue link
        run: |
          # TODOs must reference an issue: TODO(#123) or TODO(username)
          FAILED=0
          while IFS= read -r match; do
            echo "WARN: $match"
          done < <(grep -rn 'TODO[^(]' cmd/ internal/ pkg/ --include='*.go' 2>/dev/null || true)
          # Warning only, not blocking

  # ─── Stage 2: Tests with race detector ──────────────────────
  test:
    name: Test (Go ${{ matrix.go-version }}, ${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        go-version: ["1.22"]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}

      - name: Run tests with race detector
        run: go test -race -count=1 -timeout=300s ./...

      - name: Run tests with coverage
        if: matrix.os == 'ubuntu-latest'
        run: |
          go test -coverprofile=coverage.out -covermode=atomic ./...
          go tool cover -func=coverage.out | tail -1

      - name: Check coverage threshold
        if: matrix.os == 'ubuntu-latest'
        run: |
          COVERAGE=$(go tool cover -func=coverage.out | tail -1 | awk '{print $3}' | sed 's/%//')
          echo "Total coverage: ${COVERAGE}%"
          # Use bc for float comparison
          if echo "$COVERAGE < ${{ env.COVERAGE_THRESHOLD }}" | bc -l | grep -q 1; then
            echo "FAIL: Coverage ${COVERAGE}% is below threshold ${{ env.COVERAGE_THRESHOLD }}%"
            exit 1
          fi

      - name: Check rule Check() method coverage
        if: matrix.os == 'ubuntu-latest'
        run: |
          # Every rule's Check() method must have 100% coverage
          FAILED=0
          go test -coverprofile=rules-coverage.out ./internal/rules/... 2>/dev/null || true
          while IFS= read -r line; do
            if echo "$line" | grep -q '\.Check\b' && echo "$line" | grep -qv '100.0%'; then
              echo "FAIL: $line — Check() must have 100% coverage"
              FAILED=1
            fi
          done < <(go tool cover -func=rules-coverage.out 2>/dev/null || true)
          # Don't fail until rules are implemented
          if [ "$FAILED" -eq 1 ]; then
            echo "WARNING: Rule Check() coverage below 100% (will be enforced after Phase 1)"
          fi

      - name: Upload coverage
        if: matrix.os == 'ubuntu-latest'
        uses: actions/upload-artifact@v4
        with:
          name: coverage
          path: coverage.out

  # ─── Stage 3: Fuzz testing (longer, on main only) ──────────
  fuzz:
    name: Fuzz
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/next'
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Fuzz Go adapter (30s)
        run: |
          go test -fuzz=FuzzGoParser -fuzztime=30s ./internal/adapter/goparser/... 2>/dev/null || echo "No fuzz tests yet"

      - name: Fuzz TypeScript adapter (30s)
        run: |
          go test -fuzz=FuzzTypeScriptParser -fuzztime=30s ./internal/adapter/typescript/... 2>/dev/null || echo "No fuzz tests yet"

      - name: Fuzz config loader (30s)
        run: |
          go test -fuzz=FuzzConfigLoad -fuzztime=30s ./internal/config/... 2>/dev/null || echo "No fuzz tests yet"

      - name: Fuzz manifest parser (30s)
        run: |
          go test -fuzz=FuzzManifestParse -fuzztime=30s ./internal/manifest/... 2>/dev/null || echo "No fuzz tests yet"

  # ─── Stage 4: Integration tests ─────────────────────────────
  integration:
    name: Integration
    runs-on: ubuntu-latest
    needs: [test]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build binary
        run: make build

      - name: Version check
        run: ./bin/stricture --version

      - name: Self-lint
        run: ./bin/stricture . || echo "Self-lint not yet implemented"

      - name: Run integration tests
        run: go test -tags=integration -timeout=120s ./tests/integration/... 2>/dev/null || echo "No integration tests yet"

      - name: Validate exit codes
        run: |
          # Exit 0 on success
          ./bin/stricture --version; [ $? -eq 0 ] && echo "PASS: --version exits 0"

          # Exit 0 on help
          ./bin/stricture --help; [ $? -eq 0 ] && echo "PASS: --help exits 0"

          # Exit 2 on invalid flag
          ./bin/stricture --invalid-flag 2>/dev/null; [ $? -eq 2 ] && echo "PASS: invalid flag exits 2" || echo "SKIP: not yet implemented"

  # ─── Stage 5: Benchmarks (detect regressions) ───────────────
  benchmark:
    name: Benchmark
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: [test]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Run benchmarks
        run: go test -bench=. -benchmem -count=3 -timeout=300s ./... > benchmark-results.txt 2>&1 || true

      - name: Upload benchmark results
        uses: actions/upload-artifact@v4
        with:
          name: benchmark-results
          path: benchmark-results.txt

  # ─── Stage 6: Validation set ────────────────────────────────
  validate:
    name: Validation Set
    runs-on: ubuntu-latest
    needs: [integration]
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build binary
        run: make build

      - name: Health check validation set
        run: bash scripts/validation-health-check.sh 2>/dev/null || echo "Validation health check not yet configured"

      - name: Run validation set
        run: bash scripts/run-validation-set.sh 2>/dev/null || echo "Validation set not yet runnable"

  # ─── Stage 7: Build matrix (cross-platform) ─────────────────
  build:
    name: Build (${{ matrix.goos }}/${{ matrix.goarch }})
    runs-on: ubuntu-latest
    needs: [test, lint]
    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
          - goos: windows
            goarch: amd64
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Build
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0  # Will change to 1 when tree-sitter is added
        run: |
          OUTPUT="stricture-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            OUTPUT="${OUTPUT}.exe"
          fi
          go build -ldflags="-s -w -X main.version=$(cat VERSION)" -o "bin/${OUTPUT}" ./cmd/stricture

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: stricture-${{ matrix.goos }}-${{ matrix.goarch }}
          path: bin/stricture-*
